"""
Malware Analysis Module - Hash Lookup and File Analysis
"""

import aiohttp
import asyncio
import hashlib
import os
import re
import subprocess
from datetime import datetime
from typing import Dict, List


class MalwareModule:
    def __init__(self, results_folder: str, virustotal_api_key: str = ""):
        self.results_folder = results_folder
        self.vt_api_key = virustotal_api_key
        self.user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    
    def _ensure_target_folder(self, target: str) -> str:
        """Create target-specific results folder"""
        safe_target = re.sub(r'[^\w\-.]', '_', target)
        target_path = os.path.join(self.results_folder, safe_target)
        os.makedirs(target_path, exist_ok=True)
        return target_path
    
    def _save_result(self, target: str, filename: str, content: str):
        """Save results to file"""
        target_path = self._ensure_target_folder(target)
        filepath = os.path.join(target_path, filename)
        with open(filepath, 'a', encoding='utf-8') as f:
            f.write(f"\n{'='*60}\n")
            f.write(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"{'='*60}\n")
            f.write(content)
            f.write("\n")
        return filepath
    
    def calculate_hashes(self, filepath: str) -> Dict[str, str]:
        """Calculate MD5, SHA1, and SHA256 hashes"""
        try:
            md5_hash = hashlib.md5()
            sha1_hash = hashlib.sha1()
            sha256_hash = hashlib.sha256()
            
            with open(filepath, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b''):
                    md5_hash.update(chunk)
                    sha1_hash.update(chunk)
                    sha256_hash.update(chunk)
            
            return {
                'md5': md5_hash.hexdigest(),
                'sha1': sha1_hash.hexdigest(),
                'sha256': sha256_hash.hexdigest()
            }
        except Exception as e:
            return {'error': str(e)}
    
    async def lookup_hash_virustotal(self, file_hash: str) -> Dict[str, any]:
        """Lookup hash on VirusTotal"""
        if not self.vt_api_key:
            return {
                'status': 'error',
                'message': 'VirusTotal API key not configured'
            }
        
        try:
            url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
            headers = {
                'x-apikey': self.vt_api_key,
                'User-Agent': self.user_agent
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, headers=headers,
                                      timeout=aiohttp.ClientTimeout(total=15)) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        attributes = data.get('data', {}).get('attributes', {})
                        stats = attributes.get('last_analysis_stats', {})
                        
                        return {
                            'status': 'success',
                            'malicious': stats.get('malicious', 0),
                            'suspicious': stats.get('suspicious', 0),
                            'undetected': stats.get('undetected', 0),
                            'harmless': stats.get('harmless', 0),
                            'total_engines': sum(stats.values()),
                            'names': attributes.get('names', []),
                            'file_type': attributes.get('type_description', 'Unknown')
                        }
                    elif resp.status == 404:
                        return {
                            'status': 'not_found',
                            'message': 'Hash not found in VirusTotal database'
                        }
                    else:
                        return {
                            'status': 'error',
                            'message': f'VirusTotal API returned status {resp.status}'
                        }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    async def lookup_hash_online(self, file_hash: str) -> Dict[str, any]:
        """Lookup hash using free online services"""
        results = []
        
        # Try multiple free services
        services = [
            {
                'name': 'MalwareBazaar',
                'url': f'https://mb-api.abuse.ch/api/v1/',
                'method': 'POST',
                'data': {'query': 'get_info', 'hash': file_hash}
            }
        ]
        
        try:
            async with aiohttp.ClientSession() as session:
                for service in services:
                    try:
                        if service['method'] == 'POST':
                            async with session.post(service['url'], 
                                                   data=service['data'],
                                                   timeout=aiohttp.ClientTimeout(total=10)) as resp:
                                if resp.status == 200:
                                    data = await resp.json()
                                    if data.get('query_status') == 'ok':
                                        results.append({
                                            'service': service['name'],
                                            'found': True,
                                            'data': data.get('data', [])
                                        })
                                    else:
                                        results.append({
                                            'service': service['name'],
                                            'found': False
                                        })
                    except:
                        results.append({
                            'service': service['name'],
                            'error': 'Connection failed'
                        })
            
            return {
                'status': 'success',
                'results': results
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    async def extract_strings(self, filepath: str, min_length: int = 4) -> Dict[str, any]:
        """Extract readable strings from file"""
        try:
            strings = []
            
            with open(filepath, 'rb') as f:
                result = b''
                for byte in f.read():
                    if 32 <= byte <= 126:  # Printable ASCII
                        result += bytes([byte])
                    else:
                        if len(result) >= min_length:
                            strings.append(result.decode('ascii', errors='ignore'))
                        result = b''
                
                if len(result) >= min_length:
                    strings.append(result.decode('ascii', errors='ignore'))
            
            # Filter interesting strings
            interesting = []
            patterns = [
                r'https?://[^\s]+',  # URLs
                r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',  # Emails
                r'[A-Z]:\\[^\s]+',  # Windows paths
                r'/[a-z/]+',  # Unix paths
                r'HKEY_[A-Z_]+\\[^\s]+',  # Registry keys
            ]
            
            for string in strings:
                for pattern in patterns:
                    if re.search(pattern, string, re.IGNORECASE):
                        interesting.append(string)
                        break
            
            return {
                'status': 'success',
                'total_strings': len(strings),
                'interesting_strings': interesting[:100],  # Limit output
                'sample_strings': strings[:50]
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    async def extract_metadata(self, filepath: str) -> Dict[str, any]:
        """Extract file metadata"""
        try:
            results = {}
            
            # Basic file info
            stat = os.stat(filepath)
            results['size'] = stat.st_size
            results['created'] = datetime.fromtimestamp(stat.st_ctime).strftime('%Y-%m-%d %H:%M:%S')
            results['modified'] = datetime.fromtimestamp(stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S')
            
            # Try to detect file type
            try:
                with open(filepath, 'rb') as f:
                    header = f.read(16)
                    
                    # Check magic bytes
                    if header.startswith(b'MZ'):
                        results['type'] = 'PE Executable (Windows)'
                    elif header.startswith(b'\x7fELF'):
                        results['type'] = 'ELF Executable (Linux)'
                    elif header.startswith(b'PK\x03\x04'):
                        results['type'] = 'ZIP Archive'
                    elif header.startswith(b'\x50\x4b\x03\x04'):
                        results['type'] = 'JAR/APK Archive'
                    elif header.startswith(b'%PDF'):
                        results['type'] = 'PDF Document'
                    else:
                        results['type'] = 'Unknown'
            except:
                results['type'] = 'Unknown'
            
            return {
                'status': 'success',
                'metadata': results
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}
    
    async def analyze_file(self, filepath: str) -> Dict[str, any]:
        """Complete file analysis"""
        try:
            if not os.path.exists(filepath):
                return {'status': 'error', 'message': 'File not found'}
            
            results = []
            filename = os.path.basename(filepath)
            
            results.append(f"Analyzing file: {filename}\n")
            
            # Calculate hashes
            results.append("=== HASH CALCULATION ===")
            hashes = self.calculate_hashes(filepath)
            if 'error' not in hashes:
                results.append(f"MD5:    {hashes['md5']}")
                results.append(f"SHA1:   {hashes['sha1']}")
                results.append(f"SHA256: {hashes['sha256']}\n")
                
                # Lookup hash
                results.append("=== HASH LOOKUP ===")
                if self.vt_api_key:
                    vt_result = await self.lookup_hash_virustotal(hashes['sha256'])
                    if vt_result['status'] == 'success':
                        results.append(f"VirusTotal Results:")
                        results.append(f"  Malicious: {vt_result['malicious']}")
                        results.append(f"  Suspicious: {vt_result['suspicious']}")
                        results.append(f"  Undetected: {vt_result['undetected']}")
                        results.append(f"  Total Engines: {vt_result['total_engines']}")
                    else:
                        results.append(f"VirusTotal: {vt_result.get('message', 'Error')}")
                
                # Try free services
                online_result = await self.lookup_hash_online(hashes['sha256'])
                if online_result['status'] == 'success':
                    for service_result in online_result['results']:
                        if service_result.get('found'):
                            results.append(f"\n{service_result['service']}: FOUND")
                        else:
                            results.append(f"{service_result['service']}: Not found")
            
            # Extract metadata
            results.append("\n=== FILE METADATA ===")
            metadata = await self.extract_metadata(filepath)
            if metadata['status'] == 'success':
                for key, value in metadata['metadata'].items():
                    results.append(f"{key.capitalize()}: {value}")
            
            # Extract strings
            results.append("\n=== STRING EXTRACTION ===")
            strings_result = await self.extract_strings(filepath)
            if strings_result['status'] == 'success':
                results.append(f"Total strings found: {strings_result['total_strings']}")
                results.append(f"\nInteresting strings ({len(strings_result['interesting_strings'])}):")
                for s in strings_result['interesting_strings'][:20]:
                    results.append(f"  {s}")
            
            output = "\n".join(results)
            filepath_safe = re.sub(r'[^\w\-.]', '_', filename)
            save_path = self._save_result(filepath_safe, 'malware_analysis.txt', output)
            
            return {
                'status': 'success',
                'output': output,
                'file': save_path,
                'hashes': hashes
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e), 'output': ''}


# Export functions
async def analyze_file(filepath: str, results_folder: str, 
                      vt_api_key: str = "") -> Dict[str, any]:
    module = MalwareModule(results_folder, vt_api_key)
    return await module.analyze_file(filepath)

async def lookup_hash(file_hash: str, results_folder: str, 
                     vt_api_key: str = "") -> Dict[str, any]:
    module = MalwareModule(results_folder, vt_api_key)
    
    results = []
    results.append(f"Hash: {file_hash}\n")
    
    if vt_api_key:
        vt_result = await module.lookup_hash_virustotal(file_hash)
        results.append("VirusTotal Results:")
        if vt_result['status'] == 'success':
            results.append(f"  Malicious: {vt_result['malicious']}")
            results.append(f"  Suspicious: {vt_result['suspicious']}")
            results.append(f"  Undetected: {vt_result['undetected']}")
        else:
            results.append(f"  {vt_result.get('message', 'Error')}")
    
    online_result = await module.lookup_hash_online(file_hash)
    if online_result['status'] == 'success':
        results.append("\nOnline Database Results:")
        for service_result in online_result['results']:
            if service_result.get('found'):
                results.append(f"  {service_result['service']}: FOUND")
            else:
                results.append(f"  {service_result['service']}: Not found")
    
    return {
        'status': 'success',
        'output': '\n'.join(results)
    }
